# Meteor OAuth2 Server

[![Test suite](https://github.com/leaonline/oauth2-server/actions/workflows/tests.yml/badge.svg)](https://github.com/leaonline/oauth2-server/actions/workflows/tests.yml)
[![CodeQL](https://github.com/leaonline/oauth2-server/actions/workflows/codeql-analysis.yml/badge.svg)](https://github.com/leaonline/oauth2-server/actions/workflows/codeql-analysis.yml)
[![built with Meteor](https://img.shields.io/badge/Meteor-package-green?logo=meteor&logoColor=white)](https://atmospherejs.com/leaonline/oauth2-server)
[![JavaScript Style Guide](https://img.shields.io/badge/code_style-standard-brightgreen.svg)](https://standardjs.com)
[![Project Status: Active â€“ The project has reached a stable, usable state and is being actively developed.](https://www.repostatus.org/badges/latest/active.svg)](https://www.repostatus.org/#active)
![GitHub](https://img.shields.io/github/license/leaonline/oauth2-server)

This package is a implementation of the package
[@node-oauth/oauth2-server](https://github.com/node-oauth/node-oauth2-server) 
for Meteor.
It can run without `express` (we use Meteor's builtin `WebApp`) and implements 
the `authorization_code` workflow and works like the Facebook's OAuth popup.

## Changelog

View the full changelog in the [hsitory page](./HISTORY.md).

## Install
```
meteor add leaonline:oauth2-server
```

## Implementation

### Server implementation

The following example uses the full configuration with their current default values.

`server/oauth2server.js`
```javascript
import { Meteor } from "meteor/meteor"
import { OAuth2Server } from 'meteor/leaonline:oauth2-server'

const oauth2server = new OAuth2Server({
  serverOptions: {
    addAcceptedScopesHeader: true,
    addAuthorizedScopesHeader: true,
    allowBearerTokensInQueryString: false,
    allowEmptyState: false,
    authorizationCodeLifetime: 300,
    accessTokenLifetime: 3600,
    refreshTokenLifetime: 1209600,
    allowExtendedTokenAttributes: false,
    requireClientAuthentication: true
  },
  model: {
    accessTokensCollectionName: 'oauth_access_tokens',
    refreshTokensCollectionName: 'oauth_refresh_tokens',
    clientsCollectionName: 'oauth_clients',
    authCodesCollectionName: 'oauth_auth_codes',
    debug: true
  },
  routes: {
    accessTokenUrl: '/oauth/token',
    authorizeUrl: '/oauth/authorize',
    errorUrl: '/oauth/error',
    fallbackUrl: '/oauth/*'
  }
})

// this is a "secret" route that is only accessed with
// a valid token, that has been generated by the authorization_code grant flow
oauth2server.authenticatedRoute().get('/oauth/ident', function (req, res, next) {
  const user = Meteor.users.findOne(req.data.user.id)

  res.writeHead(200, {
    'Content-Type': 'application/json',
  })
  const body = JSON.stringify({
    id: user._id,
    login: user.username,
    email: user.emails[0].address,
    firstName: user.firstName,
    lastName: user.lastName,
    name: `${user.firstName} ${user.lastName}`
  })
  res.end(body)
})

oauth2server.app.use('*', function (req, res, next) {
  res.writeHead(404)
  res.end('route not found')
})

```

### Additional validation

Often, you want to restrict who of your users can access which client / service.
In order to decide to give permission or not, you can register a handler that
receives the authenticated user and the client she aims to access:

```javascript
oauth2server.validateUser(function({ user, client }) {
  // the following example uses alanning:roles to check, whether a user
  // has been assigned a role that indicates she can access the client.
  // It is up to you how you implement this logic. If all users can access
  // all registered clients, you can simply omit this call at all.
  const { clientId } = client
  const { _id } = user
  
  return Roles.userIsInRoles(_id, 'manage-app', clientId)
})
```



### Client/Popup implementation

You should install a router to handle client side routing indendently from the WebApp routes. You can for example use

```bash
$ meteor add ostrio:flow-router-extra
```

and then define a client route for your popup dialog:

`client/main.html`
```javascript
<head>
    <title>authserver</title>
</head>

<template name="layout">
    {{> yield}}
</template>
```

`client/main.js`
```javascript
import { FlowRouter } from 'meteor/ostrio:flow-router-extra'
import './authorize.html'
import './authorize'
import './main.html'

// Define the route to render the popup view
FlowRouter.route('/dialog/oauth', {
  action: function (params, queryParams) {
    this.render('layout', 'authorize', queryParams)
  }
})
```

`client/authorize.js`
```javascript
// Subscribe the list of already authorized clients
// to auto accept
Template.authorize.onCreated(function() {
  this.subscribe('authorizedOAuth');
});

// Get the login token to pass to oauth
// This is the best way to identify the logged user
Template.authorize.helpers({
  getToken: function() {
    return localStorage.getItem('Meteor.loginToken');
  }
});

// Auto click the submit/accept button if user already
// accepted this client
Template.authorize.onRendered(function() {
  var data = this.data;
  this.autorun(function(c) {
    var user = Meteor.user();
    if (user && user.oauth && user.oauth.authorizedClients && user.oauth.authorizedClients.indexOf(data.client_id()) > -1) {
      c.stop();
      $('button').click();
    }
  });
});
```

`client/authorize.html`
```html
<template name="authorize">
  {{#if currentUser}}
    <form method="post" action="{{redirect_uri}}" role="form" class="{{#unless Template.subscriptionsReady}}hidden{{/unless}}">
      <h2>Authorise</h2>
      <input type="hidden" name="allow" value="yes">
      <input type="hidden" name="token" value="{{getToken}}">
      <input type="hidden" name="client_id" value="{{client_id}}">
      <input type="hidden" name="redirect_uri" value="{{redirect_uri}}">
      <input type="hidden" name="response_type" value="code">
      <button type="submit">Authorise</button>
    </form>
    {{#unless Template.subscriptionsReady}}
      loading...
    {{/unless}}
  {{else}}
    {{> loginButtons}}
  {{/if}}
</template>
```

`client/style.css`
```css
.hidden {
  display: none;
}
```

## Testing

We use mocha with `meteortesting:mocha` to run the tests. You can run the tests in watch mode via

```bash
TEST_WATCH=1 TEST_CLIENT=0 meteor test-packages ./ --driver-package meteortesting:mocha
```

You can also run the tests once via

```bash
TEST_CLIENT=0 meteor test-packages ./ --once --driver-package meteortesting:mocha
```


## License

MIT, see [license file](./LICENSE)